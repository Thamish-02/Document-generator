## AI Summary

A file named project.py.


### Function: _try_to_skip_duplicates(func)

### Function: _remove_duplicates_from_path(path)

## Class: Project

**Description:** Projects are a simple way to manage Python folders and define how Jedi does
import resolution. It is mostly used as a parameter to :class:`.Script`.
Additionally there are functions to search a whole project.

### Function: _is_potential_project(path)

### Function: _is_django_path(directory)

**Description:** Detects the path of the very well known Django library (if used) 

### Function: get_default_project(path)

**Description:** If a project is not defined by the user, Jedi tries to define a project by
itself as well as possible. Jedi traverses folders until it finds one of
the following:

1. A ``.jedi/config.json``
2. One of the following files: ``setup.py``, ``.git``, ``.hg``,
   ``requirements.txt`` and ``MANIFEST.in``.

### Function: _remove_imports(names)

### Function: wrapper()

### Function: _get_config_folder_path(base_path)

### Function: _get_json_path(base_path)

### Function: load(cls, path)

**Description:** Loads a project from a specific path. You should not provide the path
to ``.jedi/project.json``, but rather the path to the project folder.

:param path: The path of the directory you want to use as a project.

### Function: save(self)

**Description:** Saves the project configuration in the project in ``.jedi/project.json``.

### Function: __init__(self, path)

**Description:** :param path: The base path for this project.
:param environment_path: The Python executable path, typically the path
    of a virtual environment.
:param load_unsafe_extensions: Default False, Loads extensions that are not in the
    sys path and in the local directories. With this option enabled,
    this is potentially unsafe if you clone a git repository and
    analyze it's code, because those compiled extensions will be
    important and therefore have execution privileges.
:param sys_path: list of str. You can override the sys path if you
    want. By default the ``sys.path.`` is generated by the
    environment (virtualenvs, etc).
:param added_sys_path: list of str. Adds these paths at the end of the
    sys path.
:param smart_sys_path: If this is enabled (default), adds paths from
    local directories. Otherwise you will have to rely on your packages
    being properly configured on the ``sys.path``.

### Function: path(self)

**Description:** The base path for this project.

### Function: sys_path(self)

**Description:** The sys path provided to this project. This can be None and in that
case will be auto generated.

### Function: smart_sys_path(self)

**Description:** If the sys path is going to be calculated in a smart way, where
additional paths are added.

### Function: load_unsafe_extensions(self)

**Description:** Wheter the project loads unsafe extensions.

### Function: _get_base_sys_path(self, inference_state)

### Function: _get_sys_path(self, inference_state, add_parent_paths, add_init_paths)

**Description:** Keep this method private for all users of jedi. However internally this
one is used like a public method.

### Function: get_environment(self)

### Function: search(self, string)

**Description:** Searches a name in the whole project. If the project is very big,
at some point Jedi will stop searching. However it's also very much
recommended to not exhaust the generator. Just display the first ten
results to the user.

There are currently three different search patterns:

- ``foo`` to search for a definition foo in any file or a file called
  ``foo.py`` or ``foo.pyi``.
- ``foo.bar`` to search for the ``foo`` and then an attribute ``bar``
  in it.
- ``class foo.bar.Bar`` or ``def foo.bar.baz`` to search for a specific
  API type.

:param bool all_scopes: Default False; searches not only for
    definitions on the top level of a module level, but also in
    functions and classes.
:yields: :class:`.Name`

### Function: complete_search(self, string)

**Description:** Like :meth:`.Script.search`, but completes that string. An empty string
lists all definitions in a project, so be careful with that.

:param bool all_scopes: Default False; searches not only for
    definitions on the top level of a module level, but also in
    functions and classes.
:yields: :class:`.Completion`

### Function: _search_func(self, string, complete, all_scopes)

### Function: __repr__(self)
